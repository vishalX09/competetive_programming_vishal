class dsu{
	private:
		vector<int> parent , size , rank;
	public:
		dsu(int n ){
			for(int i =0;i<n;++i){
				parent.push_back(i);
				size.push_back(1);
				rank.push_back(0);
			}
		}
		void unionbysize(int u , int v){
			int pu = findpar(u);
			int pv = findpar(v);
			if(pu == pv)
				return;
			if(size[pu] < size[pv]){
				parent[pu] = pv;
				size[pv] += size[pu];
			}
			else{
				parent[pv] = pu;
				size[pu]+= size[pv];
			}
		}

		int findpar(int node){
			if(paret[node] == node)
				return node;
			return parent[node] = findpar(parent[node]);

			// if we use there a parth compression the time complexity is O(log n)
			// if we path compression and size compression the time complexity is O(4 * alpha) 
			// alpha is veri=y close to 1
			// dont ask me for the proof if u want to learn go and learn its about 100 page
		}
		void unionbyrank(int u , int v){
			int pu = findpar(u);
			int pv = findpar(v);
			if(pu == pv)
				return;
			if(rank[pu] < rank[pv]){
				parent[pu] = pv;
			}
			else if(rank[pv] < rank[pu]){
				parent[pv] = pu;
			}
			else{
				parent[pu] = pv;
				rank[pv]++; 
			}

			//a nd the tc is same as  the unionbysize its O(4*alpha);
		}
}
